使用 php 程序，去操作磁盘上的文件。

文件类型

filetype()函数
file:文件类型，用户存储数据的一个容器。txt,jpg,exe. 后缀来标示一下。

dir ：目录类型，用于放置文件的一个盒子。

路径的操作
dirname():获取到一个路径的目录部分

截取字符串
只要字符串是一个路径的格式，就可以获取其目录的部分。
并不需要路径是真实存在于磁盘上。

不能判断谁是文件或者目录，只要是最后一个 /前面都当成是目录的部分。

basename():获取路径的文件部分

获取最后一个/的后面部分

路径不需要真实存在于磁盘上，只要是满足路径的格式即可。
realpath() :获取一个真实存在的路径的绝对路径

如果磁盘上不存在一个路径，返回false

如果吃饭上存在这个真实路径，返回此完整路径

pathinfo():以数组的形式返回路径的相关信息。

返回四个部分的信息
dirname 目录部分
basename 文件部分
extension 后缀名
filename 文件名


参1:路径
可以不是一个真实存在的路径。
参2：常量，可以获取四个部分中的任意一个
PATHINFO_DIRNAME   获取目录部分
PATHINFO_BASSENAME 获取文件部分
PATHINFO_EXTENSION 获取后缀名
PATHINFO_FILENAME  获取文件名


文件的类型：
     filetype():可以得到文件的类型
     需要是真实存在于磁盘上的路径

在获取文件类型的时候，和文件的名称没有任何关系，只和文件的功能有关。
is_file():判断文件是否是一个file类型
返回一个布尔值。

如果是file类型，返回true,否则返回false

如果不存在也返回false

is_dir():判断是否是dir类型
如果是返回true，否则返回false

file_exists()：判断一个文件是否存在于当前的磁盘
既可以判断file，也可以判断dir.

获取文件信息
filesize()获取文件的大小，只能获取file类型的文件大小。dir是不会统计目录中所有文件的大小。
获取文件的字节数
文件的大小
filectime()获取文件的创建时间

格式化时间戳date()
filemtime() 获取文件的修改时间 date('Y-m-d H:i:s',filemtime('./demo.php'));
fileatime()获取文件的访问时间  date('Y-m-d H:i:s',fileatime('./demo.php'));

目录的操作
opendir() 打开目录
参数：目录在磁盘上的路径
返回值：资源类型的数据
必须保证目录的存在

readdir()：读取目录中的内容
参数是：由opendir()打开的资源
因为有. 和 .. 的存在，所以使用./ ../ 两种表示路径的方式。
读取目录也是使用指针操作，目录中的内容，每读取到一个文件，就会将指针向下移动一次。

当指针非法的时候，返回一个false
closedir(),关闭有opendir()打开的资源
一旦关闭资源，就无法操作了。

循环遍历目录
当指针非法的时候返回一个false。
可以根据false来判断，时候需要继续执行循环操作
使用while循环来遍历目录
1.打开目录，返回一个资源类型的数据
2.使用循环一次读取里面的内容。
3.需要获取文件的大小和文件的创建时间

递归遍历目录
递归遍历目录：可以获取目录中的内容，根据文件的路径，判断该文件是不是目录。
递归的入口：如果是目录，可以进去，再一次循环，继续判断。
递归的出口：该文件不是目录，即是文件。

递归统计目录的大小
统计大小
递归的入口：如果是目录，进入该目录统计每一个文件大小
递归的出口：不是目录，统计该文件的大小。

目录的创建和删除
mkdir() 创建目录
创建之前需要判断这个目录是否存在
如果不存在才可以创建。
在目录下创建一个目录
如果只传递一个参数，必须保证前面的所有目录必须存在，才可以创建子目录
mkdir($path,0777,true);

0777表示当前目录的权限
所有者 所有组 其他
rwx rwx rwx
7     7     7
111 111 111
true 表示是否去执行递归创建
需要根据当前时间去创建一个目录
1.获取一下目录（按照时间创建） 的字符串
$dir = date('Y/m/d',time());
var_dump($dir);
生成的字符串跟目录的路径是一模一样的。

2.按照该字符串去创建目录
if(!file_exists($dir)){
     mkdir($dir,0777,true);
}

rmdir()删除目录，只能删除空目录
必须保证目录里面是空的，如果删除一个不存在的目录也会报错
unlink()删除文件
不是放到回收站，而是直接从磁盘销毁了

递归删除目录
复制和移动
copy()复制一个文件
参数：
参数1：源目标文件
参数2：复制之后的目标文件
只能复制文件，不能复制目录
rename() 移动文件，给一个文件重命名
参数1：源目录的文件
参数2：目标文件的路径位置

递归复制目录

文件的操作

文件：用于保存数据的一个容器。
打开文件
fopen() 打开文件

参数1：文件的路径
文件打成功，返回一个资源类型的数据。
参数2：打开方式
1.r 以只读的方式打开，不可以向文件中去写入文件。

2.r+ ，可读可写，从文件的首位，一次去覆盖文件中的内容
可以读出文件中的内容
可以向文件中写入内容

3.w 以只写的方式打开文件，只能向文件中写入内容，不可以读取文件中的内容。如果文件不存在，则会先创建该文件。
如果文件存在，会将文件中的内容先清空再写入。
向文件中写入内容。
将指针重置到文件的首位。

读取的是一个空的字符串，没有将文件中的内容读取出来。

4.w+ 表示既可向文件写入内容，也可读取内容。其他的和w的方式一样。

5.x,和 w 类似，如果文件不存在则创建。如果存在则报错
只可以写，不可以读取内容。

6.x+ 类似 w+ ，文件存在则报错，不存在则创建。

7.a,只写方式，将内容追加到文件的尾部，其余的类似w

8.a+ ,可读可写，其余和a是一样的

读取文件
fread() 读取文件内容

fread($handle);
需要两个参数
参数1：打开文件返回的资源
参数2：读取的内容的大小
file_get_contents():可以将文件中的所有的内容全部读取出来
读取远程服务器上的数据
file_get_contents($url);

json_decode()：将一个json格式的字符串转为数组。
传递第二个参数：true,表示将数据转为数组。

readfile() 直接将文件中的内容读取到浏览器中
file() 是以数组的形式将数据从文件中拿出来
一行是一个元素
fgets() 每一次读取文件中的一行内容
fgetc() 每次读取一个字符

写入文件
fwrite() 向一个文件中写入内容
向一个文件中写入数组是不可以的

文件中保存的数据，返回的都是一个字符串类型。
必须将数组转为字符串，才能完成存在的效果。
json格式字符串，轻量级数据格式
json_encode() 将数组转为字符串

file_put_contents()：直接将字符串写入文件中

关闭文件：
fclose()关闭文件资源
